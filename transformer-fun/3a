{-# LANGUAGE OverloadedStrings #-}

module Main where

import Data.Text
import qualified Data.Text.IO as T
import Data.Map as Map
import Control.Applicative

users :: Map Text Text
users = Map.fromList [("example.com", "qwerty123"), ("localhost", "password")]

data EitherIO e a = EitherIO { runEitherIO :: IO (Either e a) }

--instance Functor (EitherIO e) where
--  fmap f = EitherIO . fmap (fmap f) . runEitherIO
--
-- instance Applicative (EitherIO e) where
--   pure    = EitherIO . return . Right
--   f <*> x = EitherIO $ liftA2 (<*>) (runEitherIO f) (runEitherIO x)
-- 
-- instance Monad (EitherIO e) where
--   return  = pure
--   x >>= f = EitherIO $ runEitherIO x >>= either (return . Left) (runEitherIO . f)

data LoginError
    = InvalidEmail 
    | NoSuchUser
    | WrongPassword
    deriving Show

getDomain :: Text -> Either LoginError Text
getDomain email =
  case splitOn "@" email of
      [name, domain] -> Right domain
      _              -> Left InvalidEmail

printResult :: Either LoginError Text -> IO ()
printResult = T.putStrLn . either
    (const "ERROR: Invalid domain")
    (append "Domain: ")

getToken :: IO (Either LoginError Text)
getToken = do
    T.putStrLn "Enter email address:"
    email <- T.getLine
    return (getDomain email)

userLogin :: IO (Either LoginError Text)
userLogin = do
  token <- getToken
  case token of
    Right domain ->
      case Map.lookup domain users of
        Just userpw -> do
          T.putStrLn "Enter password:"
          password <- T.getLine

          if userpw == password
             then return token

             else return (Left WrongPassword)
        Nothing -> return (Left NoSuchUser)
    left -> return left


foo :: IO (Either LoginError Text)
foo = Right "bingo"


main = do 
    print "done"

    -- print $ getDomain "johndoe"
    -- print $ getDomain "johndoe@example.com"
    -- printResult $ getDomain "test"
    -- printResult $ getDomain "test@example.com"
    -- result <- userLogin
    -- print result
    
